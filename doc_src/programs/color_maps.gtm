#define HL_PROG class=curpage


#include "<<HEAD>>"
#include "<<START>>"


<<TITLE_HEAD>>

<<CONT_S_START>>
<small><a href="#colormaps">Colour maps</a></small>
<<BARSPACE>>
<small><a href="#lookup">Entry lookup</a></small>
<<BARSPACE>>
<small><a href="#params">Parameters example</a></small>
<<BARSPACE>>
<small><a href="#mods">Map index modifiers</a></small>
<<BARSPACE>>
<small><a href="#combine">Combining maps</a></small>
<<BARSPACE>>
<small><a href="#examples">Examples</a></small>
<<CONT_S_END>>



<h2><a name="colormaps">
Colour Maps
</a></h2>
<p>
OFF elements can be coloured with index numbers (integers) as well
as colour values (displayable colours). Colour maps provide a way to convert
these index numbers into colour values.
</p>
<p>
The primary documentation for colour maps can be viewed by running
<tt>off_util -H col_map</tt>. This displays the map formats supported
by Antiprism, a list of the colour maps provided with Antiprism, and the
parameters that can be used to specify and modify internal colour maps.
</p>

<h2><a name="lookup">
Map Entry Types and Sequential Lookup
</h2>
<p>
A colour map contains entries that map a colour index number to a colour
value (a colour specified by red/green/blue/alpha values) or to another
index number. A colour map might not include an entry for every
index number.
</p>
<p>
If a sequence of colour maps is being used for lookup, then each map
is used in turn for lookup. Lookup starts with the input colour index,
which becomes the current index, then the map index modifiers (general map
parameters, see below) are applied before lookup. The lookup result is:
<ul>
  <li><b>a colour value</b>, and this is returned as the final lookup result</li>
  <li><b>a colour index</b>, and this is used for lookup in the next map, or is returned as the final lookup result if there are no further maps</li>
  <li><b>no entry found</b>, and the current index is used for lookup in the next map, or is returned as the final lookup result if there are no further maps</li>
</ul>
<p>
Note that, if any map index modifiers are specified for a map then they only
modify the lookup index for this particular map. If no mapping is found
then lookup continues with the next map using the unmodified current
index (or this is the final lookup result if there are no further maps).
</p>
<p>
As a consequences of this processing, index-to-index maps can
be used to modify future maps during sequential lookup. Antiprism
includes several internal index-to-index maps
that can be used in this way (e.g. index, reverse, deal).
</p>

<h2><a name="params">
Example of Specific Parameters and Map Index Modifiers
</a></h2>

<p>
The <tt>range</tt> map is a color map that sequentially transitions
between colours. It is an internal map, generated by Antiprism, rather
than a file. The map name can include specific parameters, to
specify the colours used in the transition, and general parameters, which
are the map size and the map index modifiers, applicable to many of the internal
maps.
</p>
<p>
The <tt>range</tt> map default has size 256 and transitions between all hues
<<CMDS_START>>
col_util -d 3 -m range -Z 256 | antiview
<<CMDS_END>>
</p>
<p>
The <tt>range</tt> map accepts a map size, which immediatedly follows
the name, set here to 128 entries
<<CMDS_START>>
col_util -d 3 -m range128 -Z 256 | antiview
<<CMDS_END>>
</p>
<p>
Specific parameters for <tt>range</tt> come after any map size parameter,
if supplied, and are introduced by an underscore,  <tt>_</tt>. To
transition from red to magenta, specify these two hues. Examples
with the default map size of 256, and with a specified map size of 128
<<CMDS_START>>
col_util -d 3 -m range_H1.0:0.8 -Z 256 | antiview
col_util -d 3 -m range128_H1.0:0.8 -Z 256 | antiview
<<CMDS_END>>
</p>
<p>
After a name, and an optional map size, and an optional underscore followed
by specific parameters, some map index modifier parameters may be specified.
The general parameters can be any of <tt>+</tt> followed by a shift number,
<tt>*</tt> followed by a step number,
<tt>%</tt> optionally followed by a wrap size. If more than one of these
map index modifiers is specified then they must be specified in the order
shift before step before wrap, The following commands domnstrate the
valid parameter order
<<CMDS_START>>
col_util -d 3 -m range+5 -Z 256 | antiview
col_util -d 3 -m range*4 -Z 256 | antiview
col_util -d 3 -m range%16 -Z 256 | antiview
col_util -d 3 -m range+5*4 -Z 256 | antiview
col_util -d 3 -m range+5%16 -Z 256 | antiview
col_util -d 3 -m range*4%16 -Z 256 | antiview
col_util -d 3 -m range+5*4%16 -Z 256 | antiview
col_util -d 3 -m range128_H1.0:0.4+5*4%16 -Z 256 | antiview
<<CMDS_END>>
</p>

<h2><a name="mods">
Map Index Modifiers
</a></h2>
<p>
A map may be modified by modifying the index number that is used for
lookup. The modifiers are all optional, but must appear in the order:
shift before step before wrap. If all three modifiers are specied,
the form would therefore be
<<CMDS_START>>
map_name+shift*step%wrap
<<CMDS_END>>
</p>
<p>
Any index, idx, is modified before lookup as follows
<ul>
  <li>wrap is 0: lookup index is shift + idx*step</li>
  <li>wrap is not 0: lookup index is (shift + idx*step) % wrap [where % is modulo]<li>
</ul>
<p>
The defaults are shift=0, step=1, wrap=0. If a bare % is given then the
the wrap value will be the largest index number in the map, plus one.
Negative parameters can be specified for shift and step, but note that
the shift parameter always starts with a <tt>+</tt>, and so a shift
of -1 is specified as <tt>+-1</tt>.
</p>
<p>
If a wrap is specified without a value (a bare <tt>%</tt>), then the wrap
value used will be the largest index number in the map plus one.
</p>
<p>
The modifiers act on the lookup index rather than the map entries. If the
intention is to model a map with transformed entries, then specify "opposite"
modifiers. For example, to shift all the map entries 15 entries forward is
the same as a lookup that steps 15 entries back. However, if the map size
is finite then the entries outside of it will be lost. The lost entries
could be wrapped to the start (effectively rotating the entries in the
colour map) using a separate map that modifies the lookup from 0 to start
at map_size-16
<<CMDS_START>>
col_util -d 3 -m range128 -Z 256 | antiview
col_util -d 3 -m range128+-15 -Z 256 | antiview
col_util -d 3 -m range128+-15,range128+113 -Z 256 | antiview
<<CMDS_END>>
</p>

<h2><a name="combine">
Combining Maps
</a></h2>
<p>
A map's entries can be overriden by index-to-value maps, and manipulated by
index-to-index maps.
</p>
Examples reversing a map. Show the map, reverse using the <tt>index</tt>
map, reverse using the <tt>reverse</tt> map (note that the map size must
be specified)
<<CMDS_START>>
col_util -d 3 -m range32 -Z 256 | antiview
col_util -d 3 -m index+31*-1,range32 -Z 256 | antiview
col_util -d 3 -m reverse32,range32 -Z 256 | antiview
<<CMDS_END>>
</p>
<p>
Example randomising a map. Show the map, randomise it.
<<CMDS_START>>
col_util -d 3 -m range32 -Z 256 | antiview
col_util -d 3 -m deal32,range32 -Z 256 | antiview
<<CMDS_END>>
</p>
<p>
Example rotating entries in a map. Show the map, rotate entries three entries
forward and combine with rotating entries 29 entries back
<<CMDS_START>>
col_util -d 3 -m range32 -Z 256 | antiview
col_util -d 3 -m range32+-3,range32+29 -Z 256 | antiview
<<CMDS_END>>
</p>
<p>
Example wrapping a combined map. Show a combined map that rotates map
entries, then wrap at its size by wrapping the index number first.
<<CMDS_START>>
col_util -d 3 -m range32+-3,range32+29 -Z 256 | antiview
col_util -d 3 -m index%32,range32+-3,range32+29 -Z 256 | antiview
<<CMDS_END>>
</p>
<p>
Example of appending maps. Show a greyscale map of size 32,
append a range map of size 16, then further append a greyscale
map of size 8. The <tt>index</tt>map is used to shift back higher
index numbers before the next map is used for lookup.
<<CMDS_START>>
col_util -d 3 -m grey32 -Z 256 | antiview
col_util -d 3 -m grey32,index+-32,range16 -Z 256 | antiview
col_util -d 3 -m grey32,index+-32,range16,index+-16,grey8 -Z 256 | antiview
<<CMDS_END>>
</p>
<p>
Example of appending a reversed copy of the map (creates a smoothly
wrapping map when the base map changes smoothly but doesn't naturally
wrap). Show a map, append a copy in order, append a copy reversed.
The reversal uses the <tt>reverse</tt> map such that the second half
indexes of the double-sized map are mapped into the first half in
reverse order.
<<CMDS_START>>
col_util -d 3 -m range32_H0.5:1.0 -Z 256 | antiview
col_util -d 3 -m range32_H0.5:1.0,index+-32,range32_H0.5:1.0 -Z 256 | antiview
col_util -d 3 -m range32_H0.5:1.0,reverse64,range32_H0.5:1.0 -Z 256 | antiview
<<CMDS_END>>
</p>
<p>
Example overriding some specific entries in a map. Show a map. Specify
a colour map with the override mappings, in this example the <tt>map</tt>
map with black for index 4 (the fifth entry) and white entry for index 7,
and use it for lookup first
<<CMDS_START>>
col_util -d 3 -m range32 -Z 256 | antiview
col_util -d 3 -m map_4=black:7=white,range32 -Z 256 | antiview
<<CMDS_END>>
</p>

<h2><a name="examples">
Examples
</a></h2>
<p>
Show only some faces of a model. Make a map that colours the desired
face index numbers, and colour remaining index numbers invisible.
Show one face of small stellated dodecahedon, show square faces of
a cuboctahedron
<<CMDS_START>>
off_color sm_st_dod -f U -m map_1=red,map_invisible% | antiview
off_color cubo -f N -m map_4=red,map_invisible% | antiview
<<CMDS_END>>
</p>


#include "<<END>>"
